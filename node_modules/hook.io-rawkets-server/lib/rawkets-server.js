// Elements based on logic from WPilot

var Hook = require("hook.io").Hook,
	util = require("util"),
	Connection = require("./Connection").Connection,
	Loop = require("./Loop").Loop,
	World = require("./World").World;

var RawketsServer = exports.RawketsServer = function(options){
	Hook.call(this, options);
	var self = this;

	// Default gametype
	// TODO: Make it really easy to add in new game types without
	//       having to rewrite lots of the game world logic
	self.defaultGametype = {
		name: "Capture the flag",
		type: 0, // Code for CTF (TODO: Enumerate this)
		maxPlayers: 10,
		dimensions: {
			width: 1000,
			height: 1000
		},
		entities: {
			flag: {x: 500, y: 500}
		}
	};

	// Default values
	self.connection = null;
	self.updateTick = 1;
	self.gameloop = null;
	self.world = null;

	self.on("hook::ready", function() {
		// Start game world logic
		self.init();
	});
};

// RawketsServer inherits from Hook
util.inherits(RawketsServer, Hook);

RawketsServer.prototype.init = function() {
	var self = this;

	// 1. Decide which gametype to load

	// 2. Find message types for that game type and start connection manager
	var messageTypes = self.config.get("world:messageTypes"),
		typeIndexes = self.config.get("world:typeIndexes");
	
	self.connection = new Connection({port: 8080, messageTypes: messageTypes, typeIndexes: typeIndexes, debug: true});
	self.updateTick = 1;

	// 3. Create game world using chosen gametype
	self.world = new World({connection: self.connection});

	// 4. Set up message processing handler
	self.connection.processMessage = function(msg, client) {
		// Tried to override the processMessage with a pointer to self.processMessage
		// but I couldn't get back to the RawketsWorld scope
		self.processMessage(msg, client);
	};

	// 5. Set up connection state handlers
	// Overwrite onHandshaking method
	self.connection.onHandshaking = function(client) {
		// 1. Start game loop if it isn't already running
		if (!self.gameloop) {
			self.startGameloop();
		}

		// 2. Check there are enough slots in the game
		if (self.world.playerCount >= self.world.maxPlayers) {
			client.kill("Server is full");
			return;
		}

		// 3. Send world data to the player
		var args = [self.connection.typeIndexes.worldData, JSON.stringify(self.defaultGametype)];
		client.send(args);
	};

	// Overwrite onJoined method
	self.connection.onJoined = function(client) {
		// 1. Add player to the world
		var player = self.world.addPlayer(client.id);

		// 2. Add player to the client connection
		client.player = player;

		// 2. Send state of the world to the player (players, entities, positions, etc)
		var args = [self.connection.typeIndexes.worldState, JSON.stringify(self.world.getRepresentation())];
		client.send(args);
	};

	// Overwrite onDisconnected method
	self.connection.onDisconnected = function(client) {
		// 1. Remove player from the world
		if (client.player) {
			self.world.removePlayer(client.player.id);
			client.player = null;
		}

		// 2. Stop game loop if no players are left
		if (self.world.playerCount === 0) {
			self.stopGameloop();
		}
	};
};

RawketsServer.prototype.startGameloop = function() {
	var self = this;

	self.world.create(self.defaultGametype);

	self.gameloop = new Loop({tick: 0});
	self.gameloop.onTick = function(tick, currentTime, timeDelta) {
		self.onGameloopTick(tick, currentTime, timeDelta);
	};
	self.gameloop.start();
};

RawketsServer.prototype.stopGameloop = function(reason) {
	var self = this;
	
	for (var id in self.connection.connections) {
		self.connection.connections[id].kill(reason || "Server is shutting down");
	}

	if (!self.gameloop) {
		return;
	}

	self.gameloop.onTick = null;
	self.gameloop.stop();
	self.gameloop = null;
};

RawketsServer.prototype.onGameloopTick = function(tick, currentTime, timeDelta) {
	var self = this;

	self.world.update(currentTime, timeDelta);
	//self.checkRules(dt);
	self.sendUpdates();
};

// Process general game messages, otherwise pass them to the game world
RawketsServer.prototype.processMessage = function(msg, client) {
	var self = this,
		connectionStates = self.connection.connectionStates,
		typeIndexes = self.connection.typeIndexes,
		typeIndex = msg.typeIndex,
		args = msg.args;
	
	switch (typeIndex) {
		case typeIndexes.ping:
			client.send([typeIndexes.ping, Date.now()]);
			break;
		case typeIndexes.connect:
			client.setState(connectionStates.HANDSHAKING);
			break;
		case typeIndexes.join:
			client.setState(connectionStates.JOINED);
			break;
		default:
			if (!self.world || self.world.processMessage(msg, client) === false) {
				client.kill("Unknown message sent to server");

				if (self.debug) {
					util.log("Unknown message sent from client");
					util.log(util.inspect(msg));
				}
			}
	}
};

// Send world updates to players
RawketsServer.prototype.sendUpdates = function() {
	var self = this;

	// 1. Increase update tick counter
	self.updateTick++;

	// 2. Queue updates for each connected client
	for (var connectionId in self.connection.connections) {
		var client = self.connection.connections[connectionId];
		
		// 1. Skip client if not joined to the game yet
		if (client.state != self.connection.connectionStates.JOINED) {
			continue;
		}

		// 2. Request ping if necessary

		// 3. Skip if client update rate doesn't match up with current update tick
		if (self.updateTick % client.updateRate !== 0) {
			continue;
		}

		// 4. Prepare and queue updates relating to each player in the game
		for (var playerId in self.world.players) {
			var player = self.world.players[playerId],
				message = [self.connection.typeIndexes.playerState, player.id];

			if (player.entity) {
				message.push(player.entity.pos.x);
				message.push(player.entity.pos.y);
				message.push(player.entity.angle);
				message.push(player.entity.action);

				client.queueMessage(message);
			}
		}
	}

	// 3. Send queued messages to each client
	for (var connectionId in self.connection.connections) {
		var client = self.connection.connections[connectionId];

		// 1. Skip client if not joined to the game yet
		if (client.state != self.connection.connectionStates.JOINED) {
			continue;
		}

		// 2. Send update to client
		client.flushQueue();
	}
};