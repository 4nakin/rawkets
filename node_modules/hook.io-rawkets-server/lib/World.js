/**************************************************
** BASE GAME WORLD
**************************************************/

// Much of this is based on logic from WPilot

var util = require("util"),
	Player = require("./Player").Player,
	EntityRawket = require("./EntityRawket").EntityRawket;

var World = exports.World = function (options) {
	var self = this;

	self.roundStates = {
		WARMUP: 1, // Preparing round and waiting for players
		STARTING: 2, // Round is about to start, prepare players for battle
		RUNNING: 3, // Round has started, waiting for win scenario
		FINISHED: 4 // Round is over, reset everything for a new one
	};

	// Default values
	self.connection = options.connection || null;
	self.roundState = self.roundStates.WARMUP;
	self.maxPlayers = 0;
	self.playerCount = 0;
	self.players = {};
	self.entityCount = 0;
	self.entities = {};
	self.dimensions = {width: 0, height: 0};
};


World.prototype.create = function(gameType) {
	var self = this;

	self.roundState = self.roundStates.WARMUP;
	self.maxPlayers = gameType.maxPlayers;
	self.playerCount = 0;
	self.players = {};
	self.entityCount = 0;
	self.entities = {};
	self.dimensions = {width: gameType.dimensions.width, height: gameType.dimensions.height};
};

// Update all game entities, perform collisions, and remove destroyed objects
World.prototype.update = function(currentTime, timeDelta) {
	var self = this;

	// 1. Update the position of entities
	self.updateEntities(currentTime, timeDelta);
	
	// 2. Handle collisions between entities

	// 3. Update world state
	self.updateState(currentTime, timeDelta);

	// 4. Remove dead entities from the world
};

// Process messages related to this game type
World.prototype.processMessage = function(msg, client) {
	var self = this,
		connectionStates = self.connection.connectionStates,
		typeIndexes = self.connection.typeIndexes,
		typeIndex = msg.typeIndex,
		args = msg.args;
	
	switch (typeIndex) {
		default:
			return false;
	}
};

// Return a representation of the world right now
World.prototype.getRepresentation = function() {
	var self = this,
		players = [],
		state = {};

	// 1. Compile representation of players in the game
	for (var id in self.players) {
		players.push(self.players[id].getRepresentation());
	}

	// 2. Compile representation of other entities in the game (powerups, etc)

	// 3. Compile any other world data that is needed
	state.roundState = self.roundState;
	state.maxPlayers = self.maxPlayers;
	state.playerCount = self.playerCount;

	return {
		players: players,
		state: state
	};
};

// Add a new player to the world
World.prototype.addPlayer = function(id) {
	var self = this,
		player = new Player({id: id});
	
	// 1. Work out when to spawn the player
	switch (self.roundState) {
		// Spawn immediately if game is warming up or already running
		case self.roundStates.WARMUP:
		case self.roundStates.RUNNING:
			// 1. Set player respawn time to the current time
			player.respawnTime = Date.now();
			break;
		// Do not spawn player if game is starting or finishing
		case self.roundStates.STARTING:
		case self.roundStates.FINISHING:
			break;
	}

	// 2. Add player to the world
	self.playerCount++;
	self.players[id] = player;

	// 3. Let other players know that a new player has joined
	self.onPlayerJoin(player);

	return player;
};

// Remove player from the world
World.prototype.removePlayer = function(id) {
	var self = this,
		player = self.players[id];

	// 1. Check player exists
	if (!player) {
		return;
	}

	// 2. Remove player ship from entity list
	if (player.ship) {

	}

	// 3. Remove bullets and other entities owned by this player

	// 4. Delete player from thr world
	delete self.players[id];
	self.playerCount--;

	// 5. Let other players know that a player has left
	self.onPlayerLeave(player);
};

// New player has joined the game
World.prototype.onPlayerJoin = function(player) {
	var self = this,
		args = [self.connection.typeIndexes.playerJoined];

	// 1. Broadcast new player to everyone else
	self.connection.broadcastEach(args, function(client) {
		if (client.id == player.id) {
			return self.connection.messagePriorities.PASS;
		}

		return self.connection.messagePriorities.HIGH;
	});
};

// Player has left the game
World.prototype.onPlayerLeave = function(player) {
	var self = this,
		args = [self.connection.typeIndexes.playerLeft, player.id];

	// 1. Broadcast new player to everyone else
	self.connection.broadcast(args);
};

// Player has spawned
World.prototype.onPlayerSpawn = function(player, pos) {
	var self = this;
};

// Update entities within the world
World.prototype.updateEntities = function(currentTime, timeDelta) {
	var self = this;
	
	for (var id in self.entities) {
		var entity = self.entities[id];
		entity.worldUpdate(currentTime, timeDelta);
	}
};

// Run a function on each player
World.prototype.forEachPlayer = function(callback) {
	var self = this;

	for (var id in self.players) {
		callback(self.players[id]);
	}
};

// Spawn a player in the world
World.prototype.spawnPlayer = function(id) {
	var self = this,
		player = self.players[id],
		spawnPos;

	if (!player) {
		return;
	}

	// 1. Calculate spawn position
	spawnPos = {x: 1000, y: 1000};

	// 2. Create new rawket and add it to the world
	var rawket = new EntityRawket({pos: spawnPos, player: player});
	self.addEntity(rawket);

	// 3. Reset player attributes
	player.entity = rawket;
	player.dead = false;
	player.respawnTime = 0;

	// 4. Let others know that the player has spawned
	self.onPlayerSpawn(player, rawket.pos);
};

// Add entity to the world
World.prototype.addEntity = function(entity) {
	var self = this,
		entityId = ++self.entityCount;
	
	// 1. Set entity id
	entity.id = entityId;

	// 2. Store entity
	self.entities[entityId] = entity;
};

// Update world state (player states, weapon fire, etc)
World.prototype.updateState = function(currentTime, timeDelta) {
	var self = this,
		players = self.players;

	// Update each player
	self.forEachPlayer(function(player) {
		// 1. Spawn player if needed
		if (player.respawnTime && currentTime >= player.respawnTime) {
			self.spawnPlayer(player.id);
		}

		// 2. Update player state
		if (!player.dead) {
			var rawket = player.entity;

			// 1. Set rawket to thrust if player is pressing thrust input
			rawket.set(rawket.actionTypes.THRUST, player.is(player.actionTypes.THRUST));

			// 2. Reset player reload time if possible

			// 3. Set rawket to shoot state and fire weapon if player is pressing shoot input and not reloading
			if (player.is(player.actionTypes.SHOOT)) {
				rawket.set(rawket.actionTypes.SHOOT, true);
				self.firePlayerWeapon(player.id, rawket.angle);
			} else {
				rawket.set(rawket.actionTypes.SHOOT, false);
			}

			// 4. Replenish player health if possible
		}
	});
};