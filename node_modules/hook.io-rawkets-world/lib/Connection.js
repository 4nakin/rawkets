/**************************************************
** CONNECTION MANAGER
**************************************************/

// Much of this is based on logic from WPilot

var io = require("socket.io"),
	util = require("util");

var Connection = exports.Connection = function (options) {
	var self = this;

	self.messagePriorities = {
		HIGH: 2, // Send with the upmost urgency
		LOW: 1, // Send without getting in the way of high priority messages
		PASS: 0 // Do not send message
	};

	self.connectionStates = {
		CONNECTED: 1, // When player has connected but hasn't been authenticated
		HANDSHAKING: 1, // When player is being authenticated
		JOINED: 2, // When player has been authenticated
		DISCONNECTED: 3 // When player has disconnected
	};

	self.connection = io.listen(options.port); // Socket manager
	self.connections = {}; // Connected clients
	self.connectionCount = 0; // Number of connected clients
	self.maxConnections = 1; // Maximum amount of connected clients (not maximum amount of players in a world)
	self.debug = options.debug || false;

	// Configure Socket.IO
	self.connection.set("log level", 2);
	self.connection.set("transports", [
		"websocket"
	]);

	// Set up core methods
	self.init();

	// Initialise listeners
	self.initListeners();
};

Connection.prototype.init = function() {
	var self = this,
		Socket = io.Socket;

	Socket.prototype.queue = [];
	Socket.prototype.remoteAddress = null;

	// Set the state of the connection
	Socket.prototype.setState = function(state) {
		var client = this;

		switch (state) { 
			case self.connectionStates.CONNECTED:
				// Kick player if there are too many connections 
				if (++self.connectionCount > self.maxConnections) {
					client.kill("Too many connections");
					return;
				}

				client.queue = [];
				client.updateRate = 2;
				client.remoteAddress = client.handshake.address.address;

				self.connections[client.id] = client;

				// Method that can be overridden in game world
				self.onConnected();

				if (self.debug) {
					util.log("New player has connected: "+client.id);
				}
				break;
			case self.connectionStates.HANDSHAKING:
				// 1. Check there are enough slots in the game world
				// 2. Send world data to client (configuration, rules, etc)

				// Method that can be overridden in game world
				self.onHandshaking();
				break;
			case self.connectionStates.JOINED:
				// 1. Add player to the world
				// 2. Send state of the world to the player (players, entities, positions, etc)

				// Method that can be overridden in game world
				self.onJoined();
				break;
			case self.connectionStates.DISCONNECTED:
				delete self.connections[client.id];
				self.connectionCount--;

				// Method that can be overridden in game world
				self.onDisconnected();

				if (self.debug) {
					util.log("Player has disconnected: "+client.id);
				}
				break;
		}

		client.state = state;
	};

	// Disconnect player
	Socket.prototype.kill = function(reason) {
		var client = this,
			msg = reason || "Unknown reason";

		client.emit("disconnect", msg);
		client.onDisconnect();
	};

	// Add message to queue
	Socket.prototype.queue = function(msg) {
		var client = this;

		if (client.state !== self.connectionStates.JOINED) {
			return;
		}

		client.queue.push(msg);
	};

	// Flush messages queue
	Socket.prototype.flushQueue = function() {
		var client = this,
			packet;

		if (client.queue.length === 0) {
			return;
		}

		packet = client.queue.join(",");
		client.emit("message", packet);

		client.queue = [];
	};

	// Send a message directly to the player, bypassing the queue
	Socket.prototype.send = function(msg) {
		client.emit("message", msg);
	};

	// Called on new player connection (to be overridden)
	Socket.prototype.onConnected = function() {};

	// Called on handshaking of player connection (to be overridden)
	Socket.prototype.onHandshaking = function() {};

	// Called on player successfully joining the game (to be overridden)
	Socket.prototype.onJoined = function() {};

	// Called on player disconnection (to be overridden)
	Socket.prototype.onDisconnected = function() {};
};

Connection.prototype.initListeners = function() {
	var self = this;

	self.connection.sockets.on("connection", function(client) {
		client.on("disconnect", function() {
			client.setState(self.connectionStates.DISCONNECTED);
		});

		client.on("message", function(packet) {
			var msg = self.decodeMessage(packet);
			
			// How do I get the message out of here?
			// 1. Using events, but will that cause a race condition?
			// 2. By calling an empty method here and overriding it in the game world class (I like this more)
			//	eg. Connection.prototype.processMessage.call(this); self.connection.prototype.processMessage(msg);
			self.processMessage(msg);
		});

		// If we got here then assume the player has connected
		client.setState(self.connectionStates.CONNECTED);
	});
};

Connection.prototype.encodeMessage = function(args) {
	var self = this,
		msg = args.join("|");

	return msg;
};

Connection.prototype.decodeMessage = function(msg) {
	var self = this,
		msgParts = msg.split("|"),
		typeIndex = parseInt(msgParts.shift(), 10),
		type = self.messageTypes[typeIndex],
		args = {};

	msgParts.forEach(function(arg, index) {
		args[type.args[index]] = arg;
	});

	return {typeIndex: typeIndex, type: type, args: args};
};

// Do something with the message sent from the client
Connection.prototype.processMessage = function(msg) {
	// Overridden in game world
};

// Broadcast a message to all connected players
// No priority logic so all messages are sent immediately
Connection.prototype.broadcast = function(msg) {
	var self = this;
	
	for (var id in self.connections) {
		var client = self.connections[id];
		client.queue.push(msg);
	}
};

// Broadcast a message to all connected players
// Callback defines priority for each connection
Connection.prototype.broadcastEach = function(msg, callback) {
	var self = this;
	
	for (var id in self.connections) {
		var client = self.connections[id],
			priority = callback(client);

		// Skip messages with the pass priority
		if (priority === self.messagePriorities.PASS) {
			continue;
		}

		// Additional logic will go here to manage high and low priority messages
		// For now all messages with a priority other than pass are treated equally

		client.queue.push(msg);
	}
};

// Flush messages queue
Connection.prototype.flushQueues = function() {
	var self = this;
	
	for (var id in self.connections) {
		var client = self.connections[id];
		client.flushQueue();
	}
};