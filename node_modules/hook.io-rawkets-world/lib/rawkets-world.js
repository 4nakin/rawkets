var Hook = require("hook.io").Hook,
	util = require("util"),
	Input = require("./Input"),
	Vector = require("./Vector"),
	Player = require("./Player"),
	PlayerAI = require("./PlayerAI"),
	Bullet = require("./Bullet"),
	BulletManager = require("./BulletManager");

var RawketsWorld = exports.RawketsWorld = function(options){
	Hook.call(this, options);
	var self = this;

	// Grab world values from config
	self.worldHeight = self.config.get("world:height");
	self.worldWidth = self.config.get("world:width");
	self.maxAiPlayers = self.config.get("world:maxAiPlayers");
	self.messageTypes = self.config.get("world:messageTypes");
	self.typeIndexes = self.config.get("world:typeIndexes");

	// Prepare other variables
	self.euler = require("./Euler").init();
	self.aiPlayers = [];
	self.players = []; // Should prob move this into it's own class that manages players
	self.bullets = BulletManager.init();
	self.currentTime = Date.now(); // Current time in ms, used to calculate frame time
	self.runUpdate = true;
	//self.msgOutQueue = [];

	self.init();
};

// RawketsWorld inherits from Hook
util.inherits(RawketsWorld, Hook);

RawketsWorld.prototype.init = function() {
	var self = this;

	// Set up AI entities (move somewhere else, out of init)
	var i, x, y, playerAi;
	for (i = 0; i < self.maxAiPlayers; i++) {
		x = Math.round(Math.random()*self.worldWidth);
		y = Math.round(Math.random()*self.worldHeight);

		// Need to cut down the ID
		playerAi = PlayerAI.init("ai"+Date.now().toString()+Math.round(Math.random()*99).toString()+Math.round(Math.random()*99).toString(), "AI-"+Math.round(Math.random()*10), x, y);
		self.aiPlayers.push(playerAi);
	}

	self.initSocket();
	self.update(self);
};

RawketsWorld.prototype.initSocket = function() {
	var self = this;

	self.on("*::socket::connect", function(id) {
		console.log("New player has connected: ", id);
	});

	self.on("*::socket::disconnect", function(id) {
		console.log("Player has disconnected: ", id);

		// Remove player safely
		var player = self.playerById(id);
		if (!player) {
			return;
		}
		
		// Remove player from the players array
		var playerId = player.id;
		self.players.splice(self.indexOfByPlayerId(player.id), 1);
		console.log("Removed player from game: ", playerId);
		console.log("Total players now in game: ", self.players.length);
		
		self.emit("socket::broadcast::immediately", self.encodeMessage([self.typeIndexes.removePlayer, playerId]));
	});

	self.on("*::socket::message", function(data) {
		//console.log(data);

		var id = data.id,
			msg = data.msg,
			msgSplit,
			type,
			args,
			localPlayer,
			localPlayerState,
			player,
			playerState,
			aiPlayer,
			aiPlayerState;

		//console.log(msg);

		if (msg) {
			msgDecoded = self.decodeMessage(msg);

			if (msgDecoded.length === 0) {
				return;
			}
			
			typeIndex = parseInt(msgDecoded.typeIndex, 10);
			args = msgDecoded.args;
			
			switch (typeIndex) {
				case self.typeIndexes.ping:
					var time = Date.now();
					self.emit("socket::send::immediately::"+id, self.encodeMessage([self.typeIndexes.ping, time.toString()]));
					//util.puts("Message id "+self.MESSAGE_TYPE_PING+" sent at "+time.toString());
					break;
				case self.typeIndexes.sync:
					if (!args.screenWidth || !args.screenHeight) {
						console.log("No screen dimensions sent for player "+client.id);
						return;
					}

					// Create new player
					localPlayer = Player.init({id: id, name: "Human", x: 750, y: 300, screen: {w: args.screenWidth, h: args.screenHeight}});
					localPlayerState = localPlayer.getState(true);
		
					// Send new player to other clients
					self.emit("socket::broadcast::immediately::"+id, self.encodeMessage([self.typeIndexes.newPlayer, localPlayer.id, localPlayer.name, localPlayerState.p.x, localPlayerState.p.y, localPlayerState.a, localPlayerState.h, localPlayerState.f, localPlayer.colour]));
					
					if (!localPlayer) {
						return;
					}
					
					// Send existing players
					var p, playerCount = self.players.length;
					for (p = 0; p < playerCount; p++) {
						player = self.players[p];
						playerState = player.getState(true);

						if (!player || player.id == localPlayer.id) {
							continue;
						}

						// Need to queue these messages if the client isn't fully synced up and ready yet
						self.emit("socket::send::immediately::"+id, self.encodeMessage([self.typeIndexes.newPlayer, player.id, player.name, playerState.p.x, playerState.p.y, playerState.a, playerState.h, playerState.f, player.colour]));
					}

					var aiPlayerCount = self.aiPlayers.length;
					for (p = 0; p < aiPlayerCount; p++) {
						aiPlayer = self.aiPlayers[p];
						aiPlayerState = aiPlayer.player.getState(true);

						if (!aiPlayer) {
							continue;
						}

						// Need to queue these messages if the client isn't fully synced up and ready yet
						self.emit("socket::send::immediately::"+id, self.encodeMessage([self.typeIndexes.newPlayer, aiPlayer.player.id, aiPlayer.player.name, aiPlayerState.p.x, aiPlayerState.p.y, aiPlayerState.a, aiPlayerState.h, aiPlayerState.f, aiPlayer.player.colour]));
					}

					// Add new player
					self.players.push(localPlayer);

					console.log("New player added to game: ", id, self.currentTime);
					console.log("Total players now in game: ", self.players.length);
					
					// Sync complete
					// Should this wait until client has confirmed sync is complete?
					self.emit("socket::send::immediately::"+id, self.encodeMessage([self.typeIndexes.syncCompleted]));
					break;
				case self.typeIndexes.updateInput:
					player = self.playerById(id);
					if (player && args.forward && args.rotation && args.fire) {
						var input = Input.init(args.forward, args.rotation, args.fire);
						player.updateInput(input);
					}
					break;
				case self.typeIndexes.updatePlayerScreen:
					player = self.playerById(id);
					if (player && args.width && args.height) {
						player.screen.w = args.width;
						player.screen.h = args.height;
					}
					break;
			}
		}
	});
};


/**************************************************
** GAME LOOP
**************************************************/

RawketsWorld.prototype.update = function(self) {
	var newTime = Date.now(),
		frameTime = (newTime - self.currentTime)/1000, // Convert from ms to seconds
		player,
		playerState,
		playerCount = self.players.length,
		aiPlayer,
		aiPlayerState,
		aiPlayerCount = self.aiPlayers.length,
		i,
		bulletPos,
		newBullet,
		newBulletState;
	
	// Limit frame time to avoid "spiral of death"
	// Document what is meant by "spiral of death", and what 0.25 means
	// if (frameTime > 0.25) {
	// console.log("Frametime pegged at 0.25");
	// frameTime = 0.25;
	// };
	
	// Update game time
	self.currentTime = newTime;
	
	// Update player states
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}
		
		// Skip entity if there is no user input and the state hasn't changed
		// For now just update every entity all the time
	
		// Else update the state and continue the physics simulation
		player.updateState();
	}

	// Update AI player states
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
		
		if (!aiPlayer) {
			continue;
		}
		
		aiPlayer.update(self.players, self.aiPlayers, self.worldWidth, self.worldHeight);
		aiPlayer.player.updateState();
	}

	// Update bullet states
	self.bullets.updateState();

	// Run Euler simulation
	// For human players
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}
		
		self.euler.integrate(player.currentState, frameTime);
	}

	// For AI players
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
		
		if (!aiPlayer) {
			continue;
		}
		
		// Skip update if the entity is still
		self.euler.integrate(aiPlayer.player.currentState, frameTime);
	}

	// Update bullets
	self.bullets.update(self.euler, frameTime);

	// Check for bullet collisions
	// Sending self just for sending messages is dumb so the communication logic should be moved over here
	self.bullets.collisionAI(self.aiPlayers, self, self.encodeMessage, self.typeIndexes); // AI always die first
	self.bullets.collision(self.players, self, self.encodeMessage, self.typeIndexes);
	
	// Start loop through all game entities

	// Human players
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}

		playerState = player.getState(true);

		// Should this be done by events?
		if (player.getInput().fire == 1 && Date.now() - player.bulletTime > 400+Math.round(Math.random()*300)) {
			bulletPos = Vector.init();
			bulletPos.x = player.currentState.p.x+(Math.cos(player.currentState.a)*7);
			bulletPos.y = player.currentState.p.y+(Math.sin(player.currentState.a)*7);

			// Need to cut down the ID
			newBullet = self.bullets.add("bullet"+Date.now()+player.id, player.id, bulletPos.x, bulletPos.y, player.currentState.a, self.msgOutQueue, self.encodeMessage, self.typeIndexes);
			
			if (newBullet) {
				newBulletState = newBullet.getState(true);
				self.emit("socket::broadcast::immediately", self.encodeMessage([self.typeIndexes.newBullet, newBullet.id, newBulletState.p.x, newBulletState.p.y, newBulletState.a]));
			}

			player.bulletTime = Date.now();
		}

		self.playerWithinUpdate(player);
		
		if (player.getState() && player.getInput() && player.hasChanged()) {
			// Slim update for no client-side prediction
			//self.msgOutQueue.push({msg: self.encodeMessage([self.typeIndexes.updatePlayer, player.id, playerState.p.x, playerState.p.y, playerState.a, playerState.h, playerState.f])});
			self.emit("socket::broadcast", self.encodeMessage([self.typeIndexes.updatePlayer, player.id, playerState.p.x, playerState.p.y, playerState.a, playerState.h, playerState.f]));
		}

		if (newTime - player.getRemoteUpdatesTime() > 15000) {
			player.clearRemoteUpdateTimes(newTime);
		}
	}

	// AI players
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
			
		if (!aiPlayer) {
			continue;
		}

		aiPlayerState = aiPlayer.player.getState(true);

		// Should this be done by events?
		if (aiPlayer.player.getInput().fire == 1 && Date.now() - aiPlayer.player.bulletTime > 400+Math.round(Math.random()*300)) {
			bulletPos = Vector.init();
			bulletPos.x = aiPlayer.player.currentState.p.x+(Math.cos(aiPlayer.player.currentState.a)*7);
			bulletPos.y = aiPlayer.player.currentState.p.y+(Math.sin(aiPlayer.player.currentState.a)*7);

			// Need to cut down the ID
			newBullet = self.bullets.add("bullet"+Date.now()+aiPlayer.player.id, aiPlayer.player.id, bulletPos.x, bulletPos.y, aiPlayer.player.currentState.a, self.msgOutQueue, self.encodeMessage, self.typeIndexes);
			if (newBullet) {
				newBulletState = newBullet.getState(true);
				self.emit("socket::broadcast::immediately", self.encodeMessage([self.typeIndexes.newBullet, newBullet.id, newBulletState.p.x, newBulletState.p.y, newBulletState.a]));
			}
			aiPlayer.player.bulletTime = Date.now();
		}

		self.playerWithinUpdate(aiPlayer.player);
		
		if (aiPlayer.player.getState() && aiPlayer.player.getInput() && aiPlayer.player.hasChanged()) {
			//self.msgOutQueue.push({msg: self.encodeMessage([self.typeIndexes.updatePlayer, aiPlayer.player.id, aiPlayerState.p.x, aiPlayerState.p.y, aiPlayerState.a, aiPlayerState.h, aiPlayerState.f])});
			self.emit("socket::broadcast", self.encodeMessage([self.typeIndexes.updatePlayer, aiPlayer.player.id, aiPlayerState.p.x, aiPlayerState.p.y, aiPlayerState.a, aiPlayerState.h, aiPlayerState.f]));
		}
	}

	// End loop through all game entities
	
	// Collision detection can be performed at this point
	
	// Send updates to clients
	// Deal with queued outgoing messages
	self.emit("socket::flushQueue");
	//self.unqueueOutgoingMessages(self.msgOutQueue);
	
	// Clear outgoing messages queue
	//self.msgOutQueue = [];
	
	// Schedule next loop
	if (self.runUpdate) {
		setTimeout(function() {
			self.update(self);
		}, 1000/60);
	}
};


/**************************************************
** MESSAGE FORMATTER
**************************************************/

RawketsWorld.prototype.encodeMessage = function(args) {
	var self = this,
		msg = args.join("|");

	return msg;
};

RawketsWorld.prototype.decodeMessage = function(msg) {
	var self = this,
		msgParts = msg.split("|"),
		typeIndex = parseInt(msgParts.shift(), 10),
		type = self.messageTypes[typeIndex],
		args = {};

	msgParts.forEach(function(arg, index) {
		args[type.args[index]] = arg;
	});

	return {typeIndex: typeIndex, type: type, args: args};
};


/**************************************************
** MESSAGE QUEUES
**************************************************/

// Unqueue outgoing messages and do stuff with them
/*RawketsWorld.prototype.unqueueOutgoingMessages = function(msgQueue) {
	var self = this;

	// Check for messages
	if (msgQueue.length === 0) {
		return;
	}
	
	// Copy message queue
	var msgs = msgQueue.slice(0); // Necessary?
	
	// Do stuff with message queue
	var data, client, msg;
	while (msgs.length > 0) {
		// Grab and remove the oldest message in the array
		data = msgs.shift();
		//client = data.client || false;
		msg = data.msg;

		if (msg) {
			msgDecoded = self.decodeMessage(msg);

			if (msgDecoded.length === 0) {
				return;
			}
			
			typeIndex = parseInt(msgDecoded.typeIndex, 10);
			args = msgDecoded.args;

			var player,
				playerCount = self.players.length,
				playerX,
				playerY,
				halfScreenWidth,
				halfScreenHeight,
				updateTime,
				remotePlayerUpdateTime,
				remoteBulletUpdateTime,
				i;
			
			switch (typeIndex) {
				case self.typeIndexes.updatePlayer:
					// Only send update to players who can see this player
					for (i = 0; i < playerCount; i++) {
						player = self.players[i];

						if (!player) {
							continue;
						}

						// Skip dimensional checks as this is the local player
						if (player.id == args.id) {
							self.emit("socket::send::"+player.id, msg);
							continue;
						}

						playerX = player.currentState.p.x;
						playerY = player.currentState.p.y;

						halfScreenWidth = 200 + player.screen.w/2;
						halfScreenHeight = 200 + player.screen.h/2;

						if (args.x > playerX - halfScreenWidth && 
							args.x < playerX + halfScreenWidth &&
							args.y > playerY - halfScreenHeight &&
							args.y < playerY + halfScreenHeight) {
							updateTime = Date.now();
							remotePlayerUpdateTime = player.getRemotePlayersUpdateTime(args.id);

							// Only send remote updates every 100ms
							if (!remotePlayerUpdateTime || updateTime - remotePlayerUpdateTime > 100) {
								self.emit("socket::send::"+player.id, msg);
								player.setRemotePlayersUpdateTime(args.id, updateTime);
							}
						}
					}
					break;
				// Add "within screen" logic for bullets as they really don't
				// need to be known about if not near the player
				case self.typeIndexes.newBullet:
				case self.typeIndexes.removeBullet:
					self.emit("socket::broadcast", msg);
					break;
				case self.typeIndexes.updateBullet:
					// Only send update to players who can see this bullet
					for (i = 0; i < playerCount; i++) {
						player = self.players[i];

						if (!player) {
							continue;
						}

						playerX = player.currentState.p.x;
						playerY = player.currentState.p.y;

						halfScreenWidth = 200 + player.screen.w/2;
						halfScreenHeight = 200 + player.screen.h/2;

						if (args.x > playerX - halfScreenWidth && 
							args.x < playerX + halfScreenWidth &&
							args.y > playerY - halfScreenHeight &&
							args.y < playerY + halfScreenHeight) {
							updateTime = Date.now();
							remoteBulletUpdateTime = player.getRemoteBulletsUpdateTime(args.id);

							// Only send remote updates every 100ms
							if (!remoteBulletUpdateTime || updateTime - remoteBulletUpdateTime > 50) {
								self.emit("socket::send::"+player.id, msg);
								player.setRemoteBulletsUpdateTime(args.id, updateTime);
							}
						}
					}
					break;
			}
		}
	}
};*/


/**************************************************
** FINDING PLAYERS
**************************************************/

// Find player by ID
RawketsWorld.prototype.playerById = function(id) {
	var self = this;

	for (var i = 0; i < self.players.length; i++) {
		if (self.players[i].id == id)
			return self.players[i];
	}
	
	return false;
};

// Find player index by ID
RawketsWorld.prototype.indexOfByPlayerId = function(id) {
	var self = this;

	for (var i = 0; i < self.players.length; i++) {
		if (self.players[i].id == id) {
			return i;
		}
	}
	
	return false;
};


/**************************************************
** GAME WORLD HELPERS
**************************************************/

// World boundary checks
// Move to a viewport or world class?
RawketsWorld.prototype.withinWorldBounds = function(x, y) {
	var self = this;

	if (x > 0 && 
		x < self.worldWidth &&
		y > 0 &&
		y < self.worldHeight) {
		return true;	
	}
	
	return false;
};

RawketsWorld.prototype.playerWithinUpdate = function(player) {
	var self = this;

	var currentState = player.currentState;
	if (!self.withinWorldBounds(currentState.p.x, currentState.p.y)) {
		if (currentState.p.x > self.worldWidth) {
			currentState.p.x = self.worldWidth;
			currentState.v.x = 0;
		}

		if (currentState.p.x < 0) {
			currentState.p.x = 0;
			currentState.v.x = 0;
		}

		if (currentState.p.y > self.worldHeight) {
			currentState.p.y = self.worldHeight;
			currentState.v.y = 0;
		}

		if (currentState.p.y < 0) {
			currentState.p.y = 0;
			currentState.v.y = 0;
		}
	}
};