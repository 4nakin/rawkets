var Hook = require("hook.io").Hook,
	util = require("util"),
	Input = require("./Input"),
	Vector = require("./Vector"),
	Player = require("./Player"),
	PlayerAI = require("./PlayerAI"),
	Bullet = require("./Bullet"),
	BulletManager = require("./BulletManager");

var RawketsWorld = exports.RawketsWorld = function(options){
	Hook.call(this, options);
	var self = this;

	// Grab world values from config
	self.worldHeight = self.config.get("world:height");
	self.worldWidth = self.config.get("world:width");
	self.maxAiPlayers = self.config.get("world:maxAiPlayers");

	// Prepare other variables
	self.euler = require("./Euler").init();
	self.aiPlayers = [];
	self.players = []; // Should prob move this into it's own class that manages players
	self.bullets = BulletManager.init();
	self.currentTime = Date.now(); // Current time in ms, used to calculate frame time
	self.runUpdate = true;
	self.msgOutQueue = [];
	self.MESSAGE_TYPE_PING = 1;
	self.MESSAGE_TYPE_SYNC = 2;
	self.MESSAGE_TYPE_SYNC_COMPLETED = 3;
	self.MESSAGE_TYPE_NEW_PLAYER = 4;
	self.MESSAGE_TYPE_UPDATE_PLAYER = 5;
	self.MESSAGE_TYPE_UPDATE_INPUT = 6;
	self.MESSAGE_TYPE_REMOVE_PLAYER = 7;
	self.MESSAGE_TYPE_NEW_BULLET = 8;
	self.MESSAGE_TYPE_UPDATE_BULLET = 9;
	self.MESSAGE_TYPE_REMOVE_BULLET = 10;
	self.MESSAGE_TYPE_UPDATE_PLAYER_SCREEN = 11;

	self.init();
};

// RawketsWorld inherits from Hook
util.inherits(RawketsWorld, Hook);

RawketsWorld.prototype.init = function() {
	var self = this;

	// Set up AI entities (move somewhere else, out of init)
	var i, x, y, playerAi;
	for (i = 0; i < self.maxAiPlayers; i++) {
		x = Math.round(Math.random()*self.worldWidth);
		y = Math.round(Math.random()*self.worldHeight);

		// Need to cut down the ID
		playerAi = PlayerAI.init("ai"+Date.now().toString()+Math.round(Math.random()*99).toString()+Math.round(Math.random()*99).toString(), "AI-"+Math.round(Math.random()*10), x, y);
		self.aiPlayers.push(playerAi);
	}

	self.initSocket();
	self.update(self);
};

RawketsWorld.prototype.initSocket = function() {
	var self = this;

	self.on("*::socket::connect", function(id) {
		console.log("New player has connected: ", id);
	});

	self.on("*::socket::disconnect", function(id) {
		console.log("Player has disconnected: ", id);

		// Remove player safely
		var player = self.playerById(id);
		if (!player) {
			return;
		}
		
		// Remove player from the players array
		var playerId = player.id;
		self.players.splice(self.indexOfByPlayerId(player.id), 1);
		console.log("Removed player from game: ", playerId);
		console.log("Total players now in game: ", self.players.length);
		
		self.emit("socket::broadcast", self.formatMessage(self.MESSAGE_TYPE_REMOVE_PLAYER, {id: playerId}));
	});

	self.on("*::socket::message", function(data) {
		//sys.puts("Message id "+msg.z+" received at "+Date.now());

		var id = data.id,
			msg = data.msg,
			msgArray,
			msgType,
			player;

		if (msg && !msg.z) {
			msgArray = msg.split("|");

			if (msgArray.length === 0) {
				return;
			}
			
			type = parseInt(msgArray[0], 10);
			
			switch (type) {
				case self.MESSAGE_TYPE_PING:
					var time = Date.now();
					self.emit("socket::send::"+id, [self.MESSAGE_TYPE_PING, time.toString()].join("|"));
					//util.puts("Message id "+self.MESSAGE_TYPE_PING+" sent at "+time.toString());
					break;
			}
		}

		if (msg.z !== undefined) {
			switch (msg.z) {
				// case self.MESSAGE_TYPE_PING:
				// 	var time = Date.now();
				// 	self.emit("socket::send::"+id, [self.MESSAGE_TYPE_PING, time.toString()].join("|"));
				// 	//util.puts("Message id "+self.MESSAGE_TYPE_PING+" sent at "+time.toString());
				// 	break;
				case self.MESSAGE_TYPE_SYNC:
					if (!msg.sc) {
						console.log("No screen dimensions sent for player "+client.id);
						return;
					}

					// Create new player
					var localPlayer = Player.init({id: id, name: "Human", x: 750, y: 300, screen: msg.sc});
		
					// Send new player to other clients
					self.emit("socket::broadcast::"+id, self.formatMessage(self.MESSAGE_TYPE_NEW_PLAYER, {id: localPlayer.id, n: localPlayer.name, c: localPlayer.colour, t: self.currentTime.toString(), s: localPlayer.getState()}));
					
					if (!localPlayer) {
						return;
					}
					
					// Send existing players
					var p, playerCount = self.players.length;
					for (p = 0; p < playerCount; p++) {
						player = self.players[p];

						if (!player || player.id == localPlayer.id) {
							continue;
						}

						// Need to queue these messages if the client isn't fully synced up and ready yet
						self.emit("socket::send::"+id, self.formatMessage(self.MESSAGE_TYPE_NEW_PLAYER, {id: player.id, n: player.name, c: player.colour, t: self.currentTime.toString(), s: player.getState()}));
					}

					var aiPlayerCount = self.aiPlayers.length;
					for (p = 0; p < aiPlayerCount; p++) {
						aiPlayer = self.aiPlayers[p];

						if (!aiPlayer) {
							continue;
						}

						// Need to queue these messages if the client isn't fully synced up and ready yet
						self.emit("socket::send::"+id, self.formatMessage(self.MESSAGE_TYPE_NEW_PLAYER, {id: aiPlayer.player.id, n: aiPlayer.player.name, c: aiPlayer.player.colour, t: self.currentTime.toString(), s: aiPlayer.player.getState()}));
					}

					// Add new player
					self.players.push(localPlayer);

					console.log("New player added to game: ", id, self.currentTime);
					console.log("Total players now in game: ", self.players.length);
					
					// Sync complete
					// Should this wait until client has confirmed sync is complete?
					self.emit("socket::send::"+id, self.formatMessage(self.MESSAGE_TYPE_SYNC_COMPLETED, {}));
					break;
				case self.MESSAGE_TYPE_UPDATE_INPUT:
					player = self.playerById(id);
					if (player && msg.i) {
						player.updateInput(msg.i);
					}
					break;
				case self.MESSAGE_TYPE_UPDATE_PLAYER_SCREEN:
					player = self.playerById(id);
					if (player && msg.w && msg.h) {
						player.screen.w = msg.w;
						player.screen.h = msg.h;
					}
					break;
			}
		}
	});
};


/**************************************************
** GAME LOOP
**************************************************/

RawketsWorld.prototype.update = function(self) {
	var newTime = Date.now(),
		frameTime = (newTime - self.currentTime)/1000, // Convert from ms to seconds
		player,
		playerCount = self.players.length,
		aiPlayer,
		aiPlayerCount = self.aiPlayers.length,
		i;
	
	// Limit frame time to avoid "spiral of death"
	// Document what is meant by "spiral of death", and what 0.25 means
	// if (frameTime > 0.25) {
	// console.log("Frametime pegged at 0.25");
	// frameTime = 0.25;
	// };
	
	// Update game time
	self.currentTime = newTime;
	
	// Update player states
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}
		
		// Skip entity if there is no user input and the state hasn't changed
		// For now just update every entity all the time
	
		// Else update the state and continue the physics simulation
		player.updateState();
	}

	// Update AI player states
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
		
		if (!aiPlayer) {
			continue;
		}
		
		aiPlayer.update(self.players, self.aiPlayers, self.worldWidth, self.worldHeight);
		aiPlayer.player.updateState();
	}

	// Update bullet states
	self.bullets.updateState();

	// Run Euler simulation
	// For human players
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}
		
		self.euler.integrate(player.currentState, frameTime);
	}

	// For AI players
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
		
		if (!aiPlayer) {
			continue;
		}
		
		// Skip update if the entity is still
		self.euler.integrate(aiPlayer.player.currentState, frameTime);
	}

	// Update bullets
	self.bullets.update(self.euler, frameTime);

	// Check for bullet collisions
	self.bullets.collisionAI(self.aiPlayers, self.msgOutQueue); // AI always die first
	self.bullets.collision(self.players, self.msgOutQueue);
	
	// Start loop through all game entities

	// Human players
	for (i = 0; i < playerCount; i++) {
		player = self.players[i];
		
		if (!player) {
			continue;
		}

		// Should this be done by events?
		if (player.getInput().fire == 1 && Date.now() - player.bulletTime > 400+Math.round(Math.random()*300)) {
			var bulletPos = Vector.init();
			bulletPos.x = player.currentState.p.x+(Math.cos(player.currentState.a)*7);
			bulletPos.y = player.currentState.p.y+(Math.sin(player.currentState.a)*7);

			// Need to cut down the ID
			self.bullets.add("bullet"+Date.now()+player.id, player.id, bulletPos.x, bulletPos.y, player.currentState.a, self.msgOutQueue);
			player.bulletTime = Date.now();
		}

		self.playerWithinUpdate(player);
		
		if (player.getState() && player.getInput() && player.hasChanged()) {
			// Slim update for no client-side prediction
			self.msgOutQueue.push({msg: self.formatMessage(self.MESSAGE_TYPE_UPDATE_PLAYER, {id: player.id, s: player.getState(true)})});
		}
	}

	// AI players
	for (i = 0; i < aiPlayerCount; i++) {
		aiPlayer = self.aiPlayers[i];
			
		if (!aiPlayer) {
			continue;
		}

		// Should this be done by events?
		if (aiPlayer.player.getInput().fire == 1 && Date.now() - aiPlayer.player.bulletTime > 400+Math.round(Math.random()*300)) {
			var bulletPos = Vector.init();
			bulletPos.x = aiPlayer.player.currentState.p.x+(Math.cos(aiPlayer.player.currentState.a)*7);
			bulletPos.y = aiPlayer.player.currentState.p.y+(Math.sin(aiPlayer.player.currentState.a)*7);

			// Need to cut down the ID
			self.bullets.add("bullet"+Date.now()+aiPlayer.player.id, aiPlayer.player.id, bulletPos.x, bulletPos.y, aiPlayer.player.currentState.a, self.msgOutQueue);
			aiPlayer.player.bulletTime = Date.now();
		}

		self.playerWithinUpdate(aiPlayer.player);
		
		if (aiPlayer.player.getState() && aiPlayer.player.getInput() && aiPlayer.player.hasChanged()) {
			self.msgOutQueue.push({msg: self.formatMessage(self.MESSAGE_TYPE_UPDATE_PLAYER, {id: aiPlayer.player.id, s: aiPlayer.player.getState(true)})});
		}
	}

	// End loop through all game entities
	
	// Collision detection can be performed at this point
	
	// Send updates to clients
	// Deal with queued outgoing messages
	self.unqueueOutgoingMessages(self.msgOutQueue);
	
	// Clear outgoing messages queue
	self.msgOutQueue = [];
	
	// Schedule next loop
	if (self.runUpdate) {
		setTimeout(function() {
			self.update(self);
		}, 1000/60);
	}
};


/**************************************************
** MESSAGE FORMATTER
**************************************************/

RawketsWorld.prototype.formatMessage = function(type, args) {
	var self = this;

	var msg = {z: type};

	for (var arg in args) {
		// Don't overwrite the message type
		if (arg != "z")
			msg[arg] = args[arg];
	}

	return msg;
};


/**************************************************
** MESSAGE QUEUES
**************************************************/

// Unqueue outgoing messages and do stuff with them
RawketsWorld.prototype.unqueueOutgoingMessages = function(msgQueue) {
	var self = this;

	// Check for messages
	if (msgQueue.length === 0) {
		return;
	}
	
	// Copy message queue
	var msgs = msgQueue.slice(0); // Necessary?
	
	// Do stuff with message queue
	var data, client, msg;
	while (msgs.length > 0) {
		// Grab and remove the oldest message in the array
		data = msgs.shift();
		//client = data.client || false;
		msg = data.msg;
		
		// Only deal with messages using the correct protocol
		if (msg.z !== undefined) {
			switch (msg.z) {
				case self.MESSAGE_TYPE_UPDATE_PLAYER:
					// Only send update to players who can see this player
					var player,
						playerCount = self.players.length,
						playerX,
						playerY,
						halfScreenWidth,
						halfScreenHeight,
						i;

					for (i = 0; i < playerCount; i++) {
						player = self.players[i];

						if (!player) {
							continue;
						}

						// Skip dimensional checks as this is the local player
						if (player.id == msg.id) {
							self.emit("socket::send::"+player.id, msg);
							continue;
						}

						playerX = player.currentState.p.x;
						playerY = player.currentState.p.y;

						halfScreenWidth = 200 + player.screen.w/2;
						halfScreenHeight = 200 + player.screen.h/2;

						if (msg.s.p.x > playerX - halfScreenWidth && 
							msg.s.p.x < playerX + halfScreenWidth &&
							msg.s.p.y > playerY - halfScreenHeight &&
							msg.s.p.y < playerY + halfScreenHeight) {
							var updateTime = Date.now();

							// Only send remote updates every 100ms
							if (updateTime - player.remoteUpdateTime > 100) {
								self.emit("socket::send::"+player.id, msg);
								player.remoteUpdateTime = updateTime;
							}
						}
					}
					break;
				case self.MESSAGE_TYPE_NEW_BULLET:
				case self.MESSAGE_TYPE_UPDATE_BULLET:
				case self.MESSAGE_TYPE_REMOVE_BULLET:
					self.emit("socket::broadcast", msg);
					break;
			}
			//sys.puts("Message id "+msg.z+" sent at "+new Date().getTime().toString());
		}
	}
};


/**************************************************
** FINDING PLAYERS
**************************************************/

// Find player by ID
RawketsWorld.prototype.playerById = function(id) {
	var self = this;

	for (var i = 0; i < self.players.length; i++) {
		if (self.players[i].id == id)
			return self.players[i];
	}
	
	return false;
};

// Find player index by ID
RawketsWorld.prototype.indexOfByPlayerId = function(id) {
	var self = this;

	for (var i = 0; i < self.players.length; i++) {
		if (self.players[i].id == id) {
			return i;
		}
	}
	
	return false;
};


/**************************************************
** GAME WORLD HELPERS
**************************************************/

// World boundary checks
// Move to a viewport or world class?
RawketsWorld.prototype.withinWorldBounds = function(x, y) {
	var self = this;

	if (x > 0 && 
		x < self.worldWidth &&
		y > 0 &&
		y < self.worldHeight) {
		return true;	
	}
	
	return false;
};

RawketsWorld.prototype.playerWithinUpdate = function(player) {
	var self = this;

	var currentState = player.currentState;
	if (!self.withinWorldBounds(currentState.p.x, currentState.p.y)) {
		if (currentState.p.x > self.worldWidth) {
			currentState.p.x = self.worldWidth;
			currentState.v.x = 0;
		}

		if (currentState.p.x < 0) {
			currentState.p.x = 0;
			currentState.v.x = 0;
		}

		if (currentState.p.y > self.worldHeight) {
			currentState.p.y = self.worldHeight;
			currentState.v.y = 0;
		}

		if (currentState.p.y < 0) {
			currentState.p.y = 0;
			currentState.v.y = 0;
		}
	}
};