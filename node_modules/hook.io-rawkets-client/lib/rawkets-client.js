var Hook = require("hook.io").Hook,
	util = require("util"),
	express = require("express"),
	app,
	io;

var RawketsClient = exports.RawketsClient = function(options){
	Hook.call(this, options);
	var self = this;

	self.initExpress();
	self.initSockets();
};

// RawketsClient inherits from Hook
util.inherits(RawketsClient, Hook);

RawketsClient.prototype.initExpress = function() {
	// Configure Express
	app = express.createServer();
	io = require("socket.io").listen(app);

	app.configure(function(){
		app.set("views", __dirname + "/views");
		app.set("view engine", "hbs");
		app.use(express.bodyParser());
		app.use(express.methodOverride());
		app.use(app.router);
		app.use(express.static(__dirname + "/../../../public"));
	});

	app.configure("development", function(){
		app.use(express.errorHandler({dumpExceptions: true, showStack: true}));
	});

	app.configure("production", function(){
		app.use(express.errorHandler());
	});

	app.listen(8000);
};

RawketsClient.prototype.initSockets = function() {
	var self = this;

	// Configure Socket.IO
	io.set("log level", 2);
	io.set("transports", [
		"websocket"
	]);

	// Client connected
	io.sockets.on("connection", function(client) {
		client.queue = [];
		client.updateRate = 100; // Time in ms between updates
		client.updateTime = Date.now();

		// Flushing is going to be unpredictable and could
		// potentially lose messages until sockets communication
		// is moved into the main game world logic and not events
		client.flushQueue = function() {
			var time = Date.now(),
				packet,
				dataSent = 0;

			if (client.queue.length === 0) {
				return;
			}

			packet = client.queue.join(",");
			client.emit("game message", packet);

			dataSent = packet.length;

			client.queue = [];
			client.updateTime = time;
		};

		self.emit("socket::connect", client.id);

		// Client disconnected
		client.on("disconnect", function() {
			self.emit("socket::disconnect", client.id);
			self.removeAllListeners("*::socket::send::"+client.id);
		});

		// Client sent a message
		client.on("game message", function(msg) {
			self.emit("socket::message", {id: client.id, msg: msg});
		});

		// Send message only to this client
		self.on("*::socket::send::"+client.id, function(msg) {
			//setTimeout(function() {
				//client.emit("game message", msg);
				if (Date.now() - client.updateTime < client.updateRate) {
					return;
				}

				client.queue.push(msg);
			//}, 50);
		});

		// Immediately send message only to this client
		self.on("*::socket::send::immediately::"+client.id, function(msg) {
			//setTimeout(function() {
				client.queue.push(msg);
			//}, 50);
		});

		// Send message to everyone but this client
		self.on("*::socket::broadcast::"+client.id, function(msg) {
			var socketId,
				socketClient;

			//setTimeout(function() {
				//client.broadcast.emit("game message", msg);
				for (socketId in io.sockets.sockets) {
					if (socketId == client.id) {
						continue;
					}

					socketClient = io.sockets.sockets[socketId];

					if (Date.now() - socketClient.updateTime < socketClient.updateRate) {
						continue;
					}

					socketClient.queue.push(msg);
				}
			//}, 50);
		});

		// Immediately send message to everyone but this client
		self.on("*::socket::broadcast::immediately::"+client.id, function(msg) {
			var socketId,
				socketClient;

			//setTimeout(function() {
				//client.broadcast.emit("game message", msg);
				for (socketId in io.sockets.sockets) {
					if (socketId == client.id) {
						continue;
					}

					socketClient = io.sockets.sockets[socketId];
					socketClient.queue.push(msg);
				}
			//}, 50);
		});
	});

	// Send message to everyone
	self.on("*::socket::broadcast", function(msg) {
		var socketId,
			socketClient;

		//setTimeout(function() {
			//io.sockets.emit("game message", msg);
			for (socketId in io.sockets.sockets) {
				socketClient = io.sockets.sockets[socketId];

				if (Date.now() - socketClient.updateTime < socketClient.updateRate) {
					continue;
				}

				socketClient.queue.push(msg);
			}
		//}, 50);
	});

	// Immediately send message to everyone
	self.on("*::socket::broadcast::immediately", function(msg) {
		var socketId,
			socketClient;

		//setTimeout(function() {
			//io.sockets.emit("game message", msg);
			for (socketId in io.sockets.sockets) {
				socketClient = io.sockets.sockets[socketId];
				socketClient.queue.push(msg);
			}
		//}, 50);
	});

	// Flush message queue
	self.on("*::socket::flushQueue", function() {
		var socketId,
			socketClient;

		for (socketId in io.sockets.sockets) {
			socketClient = io.sockets.sockets[socketId];
			socketClient.flushQueue();
		}
	});
};