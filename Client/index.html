<!DOCTYPE html>

<html lang="en">

	<head>
		<title>Rawkets | A massively multiplayer game built using HTML5 canvas and WebSockets</title>
		
		<meta charset="utf-8">
		<meta name="description" content="Rawkets is a massively multiplayer game in which you can shoot and interact with other players, in real-time, in space! It uses the latest Web technologies, including HTML5 canvas and WebSockets.">
		
		<link rel="stylesheet" href="style/reset.css">
		<link rel="stylesheet" href="style/rawkets.css">
	</head>
	
	<body>
		<canvas id="canvas" width="400" height="400"></canvas>

		<script src="js/socket.io.min.js"></script>
		<script src="js/bison.js"></script>
		
		<script type="text/javascript">
			// TODO
			// Add ability to have default options for game objects and functions
			
			
			// Not using jQuery until I work out if I need it for the core game logic
			/*
			var canvas = document.getElementById("canvas");
			var game = r.game;
			game.init(canvas, window.innerWidth, window.innerHeight);
			*/
			
			// TESTING - REMOVE THIS
			var canvas = document.getElementById("canvas");
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			var ctx = canvas.getContext("2d");
			// TESTING - REMOVE THIS
			
			// Funky Object clone method
			Object.prototype.clone = function() {
				var newObj = (this instanceof Array) ? [] : {};

				for (i in this) {
					if (i == "clone") continue;

					if (this[i] && typeof this[i] == "object") {
						newObj[i] = this[i].clone();
					} else {
						newObj[i] = this[i];
					};
				};

				return newObj;
			};
			
			// Vector object
			var Vector = function(opts) {
				// Public variables
				var x = opts.x || 0,
					y = opts.y || 0;

				return {
					x: x,
					y: y
				};
			};

			// Player state object
			var PlayerState = function(opts) {
				// Private variables
				var keys = {left: false, right: false, up: false};

				// Public variables
				var pos = new Vector({x: opts.x || 0, y: opts.y || 0}),
					acc = new Vector({x: opts.acc.x || 0, y: opts.acc.y || 0});

				return {
					pos: pos,
					acc: acc,
					keys: keys
				};
			};
			
			// Player object
			var Player = function(opts) {
				// Public variables
				var id = opts.id,
					local = opts.local || false,
					currentState = new PlayerState({x: opts.x, y: opts.y, acc: {x: opts.acc.x, y: opts.acc.y}}),
					previousState = currentState.clone();

				// Public methods
				/*var update = function(dtdt) {
					// Update previous state
					previousState = currentState.clone();

					// Do stuff depending on what keys are currently pressed down
					if (currentState.keys.up) {
						currentState.acc.x += 10;
					} else {
						currentState.acc.x = 0;
					};

					// Verlet integration (http://www.gotoandplay.it/_articles/2005/08/advCharPhysics.php)
					currentState.pos.x = 2 * currentState.pos.x - previousState.pos.x + currentState.acc.x * dtdt;
					currentState.pos.y = 2 * currentState.pos.y - previousState.pos.y + currentState.acc.y * dtdt;
				};*/
				
				var draw = function(ctx) {
					var pos = (local) ? new Vector({x: canvas.width/2, y: canvas.height/2}) : currentState.pos;
					//console.log(currentState.pos.x);
					ctx.save();
					ctx.fillStyle = "rgb(255, 255, 255)";
					ctx.fillRect(pos.x-2, pos.y-2, 6, 6);
					ctx.restore();
				};

				return {
					id: id, // Should probably be made read-only
					//update: update,
					draw: draw,
					currentState: currentState,
					previousState: previousState
				};
			};
			
			// Viewport object
			var Viewport = function(width, height) {
				var worldWidth = 1000;
				var worldHeight = 1000;

				var pos = new Vector({x: 500, y: 500}); // Centre of the world
				var width = width;
				var height = height;
				
				var worldToScreen = function(x, y) {
					var screenPos = new Vector({x: 0, y: 0});

					screenPos.x = (pos.x - width/2) - x;
					screenPos.y = (pos.y - height/2) - y;

					screenPos.x *= -1;
					screenPos.y *= -1;

					return screenPos;
				};
				
				var worldXToScreenX = function(x) {
					var x = (pos.x - width/2) - x;
					x *= -1;

					return x;
				};
				
				var worldYToScreenY = function(y) {
					var y = (pos.y - height/2) - y;
					y *= -1;

					return y;
				};
				
				var draw = function(ctx) {
					ctx.strokeStyle = "rgb(200, 200, 200)";
					ctx.lineWidth = 3;

					var drawPos = new Vector(0, 0);
					var drawWidth = 0;
					var drawHeight = 0;

					if (0.0 > (pos.x - width/2)) {
						drawPos.x = worldXToScreenX(0);
					} else {
						drawPos.x = 0;
					};

					if (0.0 > (pos.y - height/2)) {
						drawPos.y = worldYToScreenY(0);
					} else {
						drawPos.y = 0;
					};

					if (worldWidth < (pos.x + width/2)) {
						drawWidth = worldXToScreenX(worldWidth);
					} else {
						drawWidth = width;
					};

					if (worldHeight < (pos.y + height/2)) {
						drawHeight = worldYToScreenY(worldHeight);
					} else {
						drawHeight = height;
					};

					ctx.strokeRect(drawPos.x-ctx.lineWidth, drawPos.y-ctx.lineWidth, drawWidth+(ctx.lineWidth*2), drawHeight+(ctx.lineWidth*2));
				};
				
				return {
					pos: pos,
					worldToScreen: worldToScreen,
					draw: draw
				};
			};
			
			// Message formatter helper
			function formatMessage(type, args) {
				var msg = {type: type};

				for (var arg in args) {
					// Don't overwrite the message type
					if (arg != "type")
						msg[arg] = args[arg];
				};

				//return JSON.stringify(msg);
				return BISON.encode(msg);
			};
			
			// Add remote player
			function addRemotePlayer(opts) {
				var id = opts.id,
					state = opts.state,
					localPos,
					player;
				
				player = new Player({id: id, x: 0, y: 0, acc: {x: 0, y: 0}});
				
				localPos = viewport.worldToScreen(state.pos.x, state.pos.y);
				
				player.currentState.pos = localPos.pos;
				player.currentState.acc = state.acc;
				player.currentState.keys = state.keys;
				
				remotePlayers.push(player);
				console.log("Add player: ", id);
			};
			
			// Find player by ID
			function playerById(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id)
						return remotePlayers[i];
				};

				return false;
			};

			// Find player index by ID
			function indexOfByPlayerId(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id) {
						return i;
					};
				};

				return false;
			};
			
			// Event listeners
			window.addEventListener("keydown", onKeydown, false);
			window.addEventListener("keyup", onKeyup, false);
			
			function onKeydown(e) {
				var c = e.keyCode;
				
				switch (c) {
					case 37: // Left
						localPlayer.currentState.keys.left = true;
						break;
					case 38: // Up
						localPlayer.currentState.keys.up = true;
						break;
					case 39: // Right
						localPlayer.currentState.keys.right = true;
						break;
					case 40: // Down
						localPlayer.currentState.keys.down = true;
						break;
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};
			
			function onKeyup(e) {
				var c = e.keyCode;

				switch (c) {
					case 37: // Left
						localPlayer.currentState.keys.left = false;
						break;
					case 38: // Up
						localPlayer.currentState.keys.up = false;
						break;
					case 39: // Right
						localPlayer.currentState.keys.right = false;
						break;
					case 40: // Down
						localPlayer.currentState.keys.down = false;
						break;
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};
			
			// Message types
			var MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE = 0,
				MESSAGE_TYPE_NEW_PLAYER = 1,
				MESSAGE_TYPE_REMOVE_PLAYER = 2,
				MESSAGE_TYPE_ENABLE_PLAYER_KEY = 3,
				MESSAGE_TYPE_DISABLE_PLAYER_KEY = 4,
				MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION = 5,
			
			// Run game
				runUpdate = true,
			
			// Socket settings
				WEB_SOCKET_SWF_LOCATION = "js/WebSocketMain.swf",
				socketHost = "194.110.243.147",
				socket = new io.Socket(socketHost, {port: 8000, transports: ["websocket", "flashsocket"]}),
				
			// Game world
				viewport = new Viewport(canvas.width, canvas.height),
			
			// Players	
				localPlayer,
				remotePlayers = [];
			
			// Connect to WebSocket server
			socket.connect();
			
			// EVENTS
			// connect, connecting, connect_failed, message, close,
			// disconnect, reconnect, reconnecting, reconnect_failed
			
			// WebSocket connection successful
			socket.on("connect", function(){
				console.log("Connected");
				localPlayer = new Player({id: false, local: true, x: 500, y: 500, acc: {x: 0, y: 0}});
				
				// Move to message queuing system
				var msg = formatMessage(MESSAGE_TYPE_NEW_PLAYER, {state: localPlayer.currentState});
				socket.send(msg);
			});
			
			// WebSocket connection failed
			socket.on("connect_failed", function() {
				console.log("Connect failed");
			});
			
			// WebSocket disconnection
			socket.on("disconnect", function() {
				console.log("Disconnected");
			});
			
			// WebSocket message received
			socket.on("message", function(data){
				var msg = BISON.decode(data);
				//console.log("Message received: ", msg);
				
				// Move this to a dedicate message queuing system
				if (msg.type !== undefined) {
					switch (msg.type) {
						case MESSAGE_TYPE_NEW_PLAYER:
							addRemotePlayer({id: msg.id, state: msg.state});
							break;
						case MESSAGE_TYPE_REMOVE_PLAYER:
							var player = playerById(msg.id);
							if (player) {
								console.log("Remove player: ", msg.id);
								remotePlayers.splice(indexOfByPlayerId(msg.id), 1);
							};
							break;
						case MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE:
							var player = playerById(msg.id),
								localPos;
							if (player) {
								//console.log("Player state: ", player.currentState);
								// THIS IS BAD â€“ CHANGE TO PREDICTIVE METHOD
								//player.currentState.pos.x = msg.state.pos.x;
								//console.log(player.currentState.pos.x);
								var localPos = viewport.worldToScreen(msg.state.pos.x, msg.state.pos.y);
								player.currentState.pos = localPos;
								player.currentState.acc = msg.state.acc;
								player.currentState.keys = msg.state.keys;
							};
							break;
						case MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION:
							if (localPlayer) {
								//localPlayer.currentState.pos = msg.pos;
								viewport.pos.x = msg.pos.x;
								viewport.pos.y = msg.pos.y;
							};
							break;
					};
				};
				
				//var state = BISON.decode(data);
				//ctx.clearRect(0, 0, canvas.width, canvas.height);
				//ctx.fillRect(state.pos.x, 100, 5, 5);
			});
			
			// Main update loop
			function update() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				viewport.draw(ctx);
				
				// Move draw functionality to another method?
				if (localPlayer != null) {
					localPlayer.draw(ctx);
				};
				
				var i, player, playerCount = remotePlayers.length;
				if (playerCount > 0) {
					for (i = 0; i < playerCount; i++) {
						player = remotePlayers[i];
						//console.log(player.currentState.pos.x);
						if (player) {
							player.draw(ctx);
						};
					};
				};
				
				// Move to message queuing system
				if (localPlayer != null && localPlayer.currentState.keys.left) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {key: 37});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.keys.left) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {key: 37});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.keys.up) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {key: 38});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.keys.up) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {key: 38});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.keys.right) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {key: 39});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.keys.right) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {key: 39});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.keys.down) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {key: 40});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.keys.down) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {key: 40});
					socket.send(msg);
				};
				
				// Schedule next game update
				if (runUpdate) {
					setTimeout(update, 1000/60); // Remember, this is however long it take to update PLUS 60ms
				};
			};
			
			// Start main update loop
			update();
		</script>
	</body>
</html>